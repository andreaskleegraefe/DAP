Aufgabe8.1.1

Problem: Finde eine Rekursionsgleichung welche das Problem beschreibt.
Eingabe: Array A[1..n] gefuellt mit zufaelligen Zahlen.
Ausgabe: Strikt unzusammenhaengendes Teilarray B von A[1..n] fuer welches die Summe seiner Elemente maximal ist.

Bsp: Eingabe: 3,6,4,-2,1,-3,4,8,2 ; Ausgabe: 3,4,1,8

1. Finde eine Rekursionsgleichung welche das Problem beschreibt.
B{A[i],suT(i+2)} wenn A[i]>A[i+1] & A[i+1]<A[i]+A[i+2] 
B{A[i+1],suT(i+3)} wenn A[i+1]>=A[i]+A[i+2]

Aufgabe8.1.2

Problem: Da bei der Loesung in 8.1 jedes Teilarray ueberprueft werden muss, ist die Laufzeit sehr schlecht. Um die Laufzeit zu verbessern versuchen 
wir nun durch dynamische Programmierung Teilergebnisse wiederzuverwenden um so die Laufzeit erheblich zu reduzieren.
	
Eingabe: Array A[1..n] gefuellt mit zufaelligen Zahlen.
Ausgabe: Strikt unzusammenhaengendes Teilarray B von A[1..n] fuer welches die Summe seiner Elemente maximal ist.

Bsp: Eingabe: 3,6,4,-2,1,-3,4,8,2 ; Ausgabe: 3,4,1,8

2. Geben sie einen Algorithmus an welcher auf dynamischer Programmierung beruht, der das Array B bestimmt

Einfacher Ansatz fuer den Algorithmus:
#	Vergleiche A[i] mit A[i+1] falls A[i+1]>A[i], vergleiche A[i+1] mit A[i]+A[i+2] falls A[i]+A[i+2]>A[i+1], wende dieses Vorgehen auf i+2 an.
#	Falls der Algorithmus das vollstaendige Array durchlaeuft z.B. A[2,3,2,3,2,3,2,3,2,3,2] gebe B[3,3,3,3,3] aus
#	Ansonsten gib den Teil aus bis wohin das Array durchlaufen wurde und wende das Verfahren erneut an z.B. A[2,3,2,3,2,2,3,2,3] waere B[3,3,3,3].

Rekursiver Algorithmus	

suT (A)	
init Array B[1..n]
if A[i]<A[i+1]
	if A[i+1]<A[i]+A[i+2] 
		B{A[i],suT(i+3)}
	else
		B{A[i+1],suT(i+3)}
else
	B{A[i],suT(i+2)}	

Dynamische Programmierung

SuT(A)
n<-length.A
if n==0 then return 0
if n==1 then return A[1]
else 
       init Array B[1..n]
       for i<-2 to n do
              if A[i-1] + A[i+1] >= A[i] + A[i+2]
                     B{A[i-1] + max{A[i+1]; A[i+2]}              
              else
                     B{A[i] + max{A[i+2]; A[i+3]} 
return B			
	

